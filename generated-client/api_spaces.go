/*
Azure IPAM

 Azure IPAM is a lightweight solution developed on top of the Azure platform designed to help Azure customers manage their enterprise IP Address space easily and effectively. 

API version: 3.4.0
Contact: ipam@microsoft.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SpacesAPIService SpacesAPI service
type SpacesAPIService service

type ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	expand *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest) Expand(expand bool) ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest {
	r.expand = &expand
	return r
}

// Azure Bearer token
func (r ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest) Authorization(authorization string) ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest) Execute() (*ResponseAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet, *http.Response, error) {
	return r.ApiService.AvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetExecute(r)
}

/*
AvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet List Available Block Networks

Get a list of Azure networks which can be associated to the target Block.
This list is a combination on Virtual Networks and vWAN Virtual Hubs.
Any Networks which overlap outstanding reservations are excluded.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest
*/
func (a *SpacesAPIService) AvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet(ctx context.Context, space string, block string) ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest {
	return ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return ResponseAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet
func (a *SpacesAPIService) AvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetExecute(r ApiAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGetRequest) (*ResponseAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseAvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.AvailableBlockNetsApiSpacesSpaceBlocksBlockAvailableGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBlockApiSpacesSpaceBlocksPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	blockReq *BlockReq
	authorization *string
}

func (r ApiCreateBlockApiSpacesSpaceBlocksPostRequest) BlockReq(blockReq BlockReq) ApiCreateBlockApiSpacesSpaceBlocksPostRequest {
	r.blockReq = &blockReq
	return r
}

// Azure Bearer token
func (r ApiCreateBlockApiSpacesSpaceBlocksPostRequest) Authorization(authorization string) ApiCreateBlockApiSpacesSpaceBlocksPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateBlockApiSpacesSpaceBlocksPostRequest) Execute() (*Block, *http.Response, error) {
	return r.ApiService.CreateBlockApiSpacesSpaceBlocksPostExecute(r)
}

/*
CreateBlockApiSpacesSpaceBlocksPost Create a new Block

Create an new Block within a Space with the following details:

- **name**: Name of the Block
- **cidr**: IPv4 CIDR Range

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiCreateBlockApiSpacesSpaceBlocksPostRequest
*/
func (a *SpacesAPIService) CreateBlockApiSpacesSpaceBlocksPost(ctx context.Context, space string) ApiCreateBlockApiSpacesSpaceBlocksPostRequest {
	return ApiCreateBlockApiSpacesSpaceBlocksPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return Block
func (a *SpacesAPIService) CreateBlockApiSpacesSpaceBlocksPostExecute(r ApiCreateBlockApiSpacesSpaceBlocksPostRequest) (*Block, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Block
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateBlockApiSpacesSpaceBlocksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockReq == nil {
		return localVarReturnValue, nil, reportError("blockReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.blockReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	vNet *VNet
	authorization *string
}

func (r ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest) VNet(vNet VNet) ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest {
	r.vNet = &vNet
	return r
}

// Azure Bearer token
func (r ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest) Authorization(authorization string) ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest) Execute() (*BlockBasic, *http.Response, error) {
	return r.ApiService.CreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostExecute(r)
}

/*
CreateBlockNetApiSpacesSpaceBlocksBlockNetworksPost Add Block Network

Associate a network to the target Block with the following information:

- **id**: Azure Resource ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest
*/
func (a *SpacesAPIService) CreateBlockNetApiSpacesSpaceBlocksBlockNetworksPost(ctx context.Context, space string, block string) ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest {
	return ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return BlockBasic
func (a *SpacesAPIService) CreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostExecute(r ApiCreateBlockNetApiSpacesSpaceBlocksBlockNetworksPostRequest) (*BlockBasic, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BlockBasic
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateBlockNetApiSpacesSpaceBlocksBlockNetworksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vNet == nil {
		return localVarReturnValue, nil, reportError("vNet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.vNet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	blockCIDRReq *BlockCIDRReq
	authorization *string
}

func (r ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest) BlockCIDRReq(blockCIDRReq BlockCIDRReq) ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest {
	r.blockCIDRReq = &blockCIDRReq
	return r
}

// Azure Bearer token
func (r ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest) Authorization(authorization string) ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest) Execute() (*ReservationExpand, *http.Response, error) {
	return r.ApiService.CreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostExecute(r)
}

/*
CreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPost Create CIDR Reservation

Create a CIDR Reservation for the target Block with the following information:

- **size**: Network mask bits
- **cidr**: Specific CIDR to reserve (alternative to 'size')
- **desc**: Description (optional)
- **reverse_search**:
    - **true**: New networks will be created as close to the <u>end</u> of the block as possible
    - **false (default)**: New networks will be created as close to the <u>beginning</u> of the block as possible
- **smallest_cidr**:
    - **true**: New networks will be created using the smallest possible available block (e.g. it will not break up large CIDR blocks when possible)
    - **false (default)**: New networks will be created using the first available block, regardless of size

### <u>Usage Examples</u>

#### *Request a new /24:*

```json
{
    "size": 24
    "desc": "New CIDR for Business Unit 1"
}
```

#### *Request a new /24, searching from the end of the CIDR range:*

```json
{
    "size": 24,
    "desc": "New CIDR for Business Unit 1",
    "reverse_search": true
}
```

#### *Request a new /24, searching from the end of the CIDR range, using the smallest available CIDR block from the available address space:*

```json
{
    "size": 24,
    "desc": "New CIDR for Business Unit 1",
    "reverse_search": true,
    "smallest_cidr": true
}
```

#### *Request a specific /24:*

```json
{
    "cidr": "10.0.100.0/24",
    "desc" "New CIDR for Business Unit 1"
}
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest
*/
func (a *SpacesAPIService) CreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPost(ctx context.Context, space string, block string) ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest {
	return ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return ReservationExpand
func (a *SpacesAPIService) CreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostExecute(r ApiCreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPostRequest) (*ReservationExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateBlockReservationApiSpacesSpaceBlocksBlockReservationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockCIDRReq == nil {
		return localVarReturnValue, nil, reportError("blockCIDRReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.blockCIDRReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	extNetReq *ExtNetReq
	authorization *string
}

func (r ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest) ExtNetReq(extNetReq ExtNetReq) ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest {
	r.extNetReq = &extNetReq
	return r
}

// Azure Bearer token
func (r ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest) Authorization(authorization string) ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest) Execute() (*ExtNetExpand, *http.Response, error) {
	return r.ApiService.CreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostExecute(r)
}

/*
CreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPost Create External Network

Create an External Network within the target Block with the following information:

- **name**: Name of the external network
- **desc**: Description of the external network
- **cidr**: CIDR of the external network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest
*/
func (a *SpacesAPIService) CreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPost(ctx context.Context, space string, block string) ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest {
	return ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return ExtNetExpand
func (a *SpacesAPIService) CreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostExecute(r ApiCreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPostRequest) (*ExtNetExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtNetExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateExternalNetworkApiSpacesSpaceBlocksBlockExternalsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.extNetReq == nil {
		return localVarReturnValue, nil, reportError("extNetReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.extNetReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	extSubnetReq *ExtSubnetReq
	authorization *string
}

func (r ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest) ExtSubnetReq(extSubnetReq ExtSubnetReq) ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest {
	r.extSubnetReq = &extSubnetReq
	return r
}

// Azure Bearer token
func (r ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest) Authorization(authorization string) ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest) Execute() (*ExtSubnetExpand, *http.Response, error) {
	return r.ApiService.CreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostExecute(r)
}

/*
CreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPost Create External Network Subnet

Create a Subnet within the target External Network with the following information:

- **name**: Name of the subnet
- **desc**: Description (optional)
- **size**: Network mask bits
- **cidr**: Specific CIDR of the subnet (alternative to size)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target External Network
 @return ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest
*/
func (a *SpacesAPIService) CreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPost(ctx context.Context, space string, block string, external string) ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest {
	return ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
	}
}

// Execute executes the request
//  @return ExtSubnetExpand
func (a *SpacesAPIService) CreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostExecute(r ApiCreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPostRequest) (*ExtSubnetExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtSubnetExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.extSubnetReq == nil {
		return localVarReturnValue, nil, reportError("extSubnetReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.extSubnetReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	extEndpointReq *ExtEndpointReq
	authorization *string
}

func (r ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest) ExtEndpointReq(extEndpointReq ExtEndpointReq) ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest {
	r.extEndpointReq = &extEndpointReq
	return r
}

// Azure Bearer token
func (r ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest) Authorization(authorization string) ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest) Execute() (*ExtEndpoint, *http.Response, error) {
	return r.ApiService.CreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostExecute(r)
}

/*
CreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPost Add External Network Subnet Endpoint

Create an Endpoint within the target External Network Subnet with the following information:

- **name**: Name of the endpoint
- **desc**: Description of the endpoint
- **ip**: IP Address of the endpoint or NONE to automatically assign the next available IP address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target External Network
 @param subnet Name of the target External Network Subnet
 @return ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest
*/
func (a *SpacesAPIService) CreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPost(ctx context.Context, space string, block string, external string, subnet string) ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest {
	return ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return ExtEndpoint
func (a *SpacesAPIService) CreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostExecute(r ApiCreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPostRequest) (*ExtEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.extEndpointReq == nil {
		return localVarReturnValue, nil, reportError("extEndpointReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.extEndpointReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	spaceCIDRReq *SpaceCIDRReq
	authorization *string
}

func (r ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest) SpaceCIDRReq(spaceCIDRReq SpaceCIDRReq) ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest {
	r.spaceCIDRReq = &spaceCIDRReq
	return r
}

// Azure Bearer token
func (r ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest) Authorization(authorization string) ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest) Execute() (*ReservationExpand, *http.Response, error) {
	return r.ApiService.CreateMultiBlockReservationApiSpacesSpaceReservationsPostExecute(r)
}

/*
CreateMultiBlockReservationApiSpacesSpaceReservationsPost Create CIDR Reservation from List of Blocks

Create a CIDR Reservation for the first available Block from a list of Blocks with the following information:

- **blocks**: Array of Block names (*Evaluated in the order provided*)
- **size**: Network mask bits
- **desc**: Description (optional)
- **reverse_search**:
    - **true**: New networks will be created as close to the <u>end</u> of the block as possible
    - **false (default)**: New networks will be created as close to the <u>beginning</u> of the block as possible
- **smallest_cidr**:
    - **true**: New networks will be created using the smallest possible available block (e.g. it will not break up large CIDR blocks when possible)
    - **false (default)**: New networks will be created using the first available block, regardless of size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest
*/
func (a *SpacesAPIService) CreateMultiBlockReservationApiSpacesSpaceReservationsPost(ctx context.Context, space string) ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest {
	return ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return ReservationExpand
func (a *SpacesAPIService) CreateMultiBlockReservationApiSpacesSpaceReservationsPostExecute(r ApiCreateMultiBlockReservationApiSpacesSpaceReservationsPostRequest) (*ReservationExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateMultiBlockReservationApiSpacesSpaceReservationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.spaceCIDRReq == nil {
		return localVarReturnValue, nil, reportError("spaceCIDRReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.spaceCIDRReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSpaceApiSpacesPostRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	spaceReq *SpaceReq
	authorization *string
}

func (r ApiCreateSpaceApiSpacesPostRequest) SpaceReq(spaceReq SpaceReq) ApiCreateSpaceApiSpacesPostRequest {
	r.spaceReq = &spaceReq
	return r
}

// Azure Bearer token
func (r ApiCreateSpaceApiSpacesPostRequest) Authorization(authorization string) ApiCreateSpaceApiSpacesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCreateSpaceApiSpacesPostRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.CreateSpaceApiSpacesPostExecute(r)
}

/*
CreateSpaceApiSpacesPost Create New Space

Create an new Space with the following details:

- **name**: Name of the Space
- **desc**: A description for the Space

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSpaceApiSpacesPostRequest
*/
func (a *SpacesAPIService) CreateSpaceApiSpacesPost(ctx context.Context) ApiCreateSpaceApiSpacesPostRequest {
	return ApiCreateSpaceApiSpacesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Space
func (a *SpacesAPIService) CreateSpaceApiSpacesPostExecute(r ApiCreateSpaceApiSpacesPostRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.CreateSpaceApiSpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.spaceReq == nil {
		return localVarReturnValue, nil, reportError("spaceReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.spaceReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	force *bool
	authorization *string
}

// Forcefully delete a Block with existing networks and/or reservations
func (r ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest) Force(force bool) ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest {
	r.force = &force
	return r
}

// Azure Bearer token
func (r ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest) Authorization(authorization string) ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteBlockApiSpacesSpaceBlocksBlockDeleteExecute(r)
}

/*
DeleteBlockApiSpacesSpaceBlocksBlockDelete Delete a Block

Remove a specific Block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest
*/
func (a *SpacesAPIService) DeleteBlockApiSpacesSpaceBlocksBlockDelete(ctx context.Context, space string, block string) ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest {
	return ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteBlockApiSpacesSpaceBlocksBlockDeleteExecute(r ApiDeleteBlockApiSpacesSpaceBlocksBlockDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteBlockApiSpacesSpaceBlocksBlockDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	requestBody *[]string
	authorization *string
}

func (r ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest) RequestBody(requestBody []string) ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest {
	r.requestBody = &requestBody
	return r
}

// Azure Bearer token
func (r ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest) Authorization(authorization string) ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteExecute(r)
}

/*
DeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDelete Remove Block Networks

Remove one or more networks currently associated to the target Block with the following information:

- **[&lt;str&gt;]**: Array of Azure Resource ID's

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest
*/
func (a *SpacesAPIService) DeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDelete(ctx context.Context, space string, block string) ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest {
	return ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteExecute(r ApiDeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteBlockNetsApiSpacesSpaceBlocksBlockNetworksDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	requestBody *[]string
	authorization *string
}

func (r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest) RequestBody(requestBody []string) ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest {
	r.requestBody = &requestBody
	return r
}

// Azure Bearer token
func (r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest) Authorization(authorization string) ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteExecute(r)
}

/*
DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDelete Delete CIDR Reservations

Remove one or more CIDR Reservations for the target Block.

- **[&lt;str&gt;]**: Array of CIDR Reservation ID's

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest
*/
func (a *SpacesAPIService) DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDelete(ctx context.Context, space string, block string) ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest {
	return ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
func (a *SpacesAPIService) DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteExecute(r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	reservation string
	authorization *string
}

// Azure Bearer token
func (r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest) Authorization(authorization string) ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteExecute(r)
}

/*
DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDelete Delete CIDR Reservation

Remove a specific CIDR Reservation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param reservation ID of the target Reservation
 @return ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest
*/
func (a *SpacesAPIService) DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDelete(ctx context.Context, space string, block string, reservation string) ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest {
	return ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		reservation: reservation,
	}
}

// Execute executes the request
func (a *SpacesAPIService) DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteExecute(r ApiDeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/reservations/{reservation}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservation"+"}", url.PathEscape(parameterValueToString(r.reservation, "reservation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	force *bool
	authorization *string
}

// Forcefully delete an External Network with existing Subnets
func (r ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest) Force(force bool) ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest {
	r.force = &force
	return r
}

// Azure Bearer token
func (r ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest) Authorization(authorization string) ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteExecute(r)
}

/*
DeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDelete Remove External Network

Remove a specific External Network currently associated to the target Block

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @return ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest
*/
func (a *SpacesAPIService) DeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDelete(ctx context.Context, space string, block string, external string) ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest {
	return ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteExecute(r ApiDeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	force *bool
	authorization *string
}

// Forcefully delete an External Network with existing Subnets
func (r ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest) Force(force bool) ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest {
	r.force = &force
	return r
}

// Azure Bearer token
func (r ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest) Authorization(authorization string) ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteExecute(r)
}

/*
DeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDelete Remove External Network Subnet

Remove a specific Subnet currently associated to the target External Network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @param subnet Name of the target external subnet
 @return ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest
*/
func (a *SpacesAPIService) DeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDelete(ctx context.Context, space string, block string, external string, subnet string) ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest {
	return ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteExecute(r ApiDeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	endpoint string
	authorization *string
}

// Azure Bearer token
func (r ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest) Authorization(authorization string) ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteExecute(r)
}

/*
DeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDelete Remove External Network Subnet Endpoint

Remove a specific Endpoint currently associated to the target External Network Subnet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @param subnet Name of the target external subnet
 @param endpoint Name of the target external subnet endpoint
 @return ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest
*/
func (a *SpacesAPIService) DeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDelete(ctx context.Context, space string, block string, external string, subnet string, endpoint string) ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest {
	return ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
		endpoint: endpoint,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteExecute(r ApiDeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints/{endpoint}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint"+"}", url.PathEscape(parameterValueToString(r.endpoint, "endpoint")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	requestBody *[]string
	authorization *string
}

func (r ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest) RequestBody(requestBody []string) ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest {
	r.requestBody = &requestBody
	return r
}

// Azure Bearer token
func (r ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest) Authorization(authorization string) ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteExecute(r)
}

/*
DeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDelete Remove External Network Subnet Endpoints

Remove one or more Endpopints currently associated to the target External Network Subnet with the following information:

- **[&lt;str&gt;]**: Array of Endpoint Names

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target External Network
 @param subnet Name of the target External Network Subnet
 @return ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest
*/
func (a *SpacesAPIService) DeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDelete(ctx context.Context, space string, block string, external string, subnet string) ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest {
	return ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteExecute(r ApiDeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSpaceApiSpacesSpaceDeleteRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	force *bool
	authorization *string
}

// Forcefully delete a Space with existing Blocks
func (r ApiDeleteSpaceApiSpacesSpaceDeleteRequest) Force(force bool) ApiDeleteSpaceApiSpacesSpaceDeleteRequest {
	r.force = &force
	return r
}

// Azure Bearer token
func (r ApiDeleteSpaceApiSpacesSpaceDeleteRequest) Authorization(authorization string) ApiDeleteSpaceApiSpacesSpaceDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteSpaceApiSpacesSpaceDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteSpaceApiSpacesSpaceDeleteExecute(r)
}

/*
DeleteSpaceApiSpacesSpaceDelete Delete a Space

Remove a specific Space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiDeleteSpaceApiSpacesSpaceDeleteRequest
*/
func (a *SpacesAPIService) DeleteSpaceApiSpacesSpaceDelete(ctx context.Context, space string) ApiDeleteSpaceApiSpacesSpaceDeleteRequest {
	return ApiDeleteSpaceApiSpacesSpaceDeleteRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) DeleteSpaceApiSpacesSpaceDeleteExecute(r ApiDeleteSpaceApiSpacesSpaceDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.DeleteSpaceApiSpacesSpaceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	expand *bool
	utilization *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest) Expand(expand bool) ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest {
	r.expand = &expand
	return r
}

// Append utilization information for each network
func (r ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest) Utilization(utilization bool) ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest {
	r.utilization = &utilization
	return r
}

// Azure Bearer token
func (r ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest) Authorization(authorization string) ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest) Execute() (*ResponseGetBlockApiSpacesSpaceBlocksBlockGet, *http.Response, error) {
	return r.ApiService.GetBlockApiSpacesSpaceBlocksBlockGetExecute(r)
}

/*
GetBlockApiSpacesSpaceBlocksBlockGet Get Block Details

Get the details of a specific Block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest
*/
func (a *SpacesAPIService) GetBlockApiSpacesSpaceBlocksBlockGet(ctx context.Context, space string, block string) ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest {
	return ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return ResponseGetBlockApiSpacesSpaceBlocksBlockGet
func (a *SpacesAPIService) GetBlockApiSpacesSpaceBlocksBlockGetExecute(r ApiGetBlockApiSpacesSpaceBlocksBlockGetRequest) (*ResponseGetBlockApiSpacesSpaceBlocksBlockGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetBlockApiSpacesSpaceBlocksBlockGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetBlockApiSpacesSpaceBlocksBlockGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	if r.utilization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "utilization", r.utilization, "form", "")
	} else {
		var defaultValue bool = false
		r.utilization = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	expand *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest) Expand(expand bool) ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest {
	r.expand = &expand
	return r
}

// Azure Bearer token
func (r ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest) Authorization(authorization string) ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest) Execute() (*ResponseGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet, *http.Response, error) {
	return r.ApiService.GetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetExecute(r)
}

/*
GetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet List Block Networks

Get a list of virtual networks which are currently associated to the target Block.
This list is a combination on Virtual Networks and vWAN Virtual Hubs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest
*/
func (a *SpacesAPIService) GetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet(ctx context.Context, space string, block string) ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest {
	return ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return ResponseGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet
func (a *SpacesAPIService) GetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetExecute(r ApiGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGetRequest) (*ResponseGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetBlockNetsApiSpacesSpaceBlocksBlockNetworksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	settled *bool
	authorization *string
}

// Include settled reservations.
func (r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest) Settled(settled bool) ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest {
	r.settled = &settled
	return r
}

// Azure Bearer token
func (r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest) Authorization(authorization string) ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest) Execute() ([]ReservationExpand, *http.Response, error) {
	return r.ApiService.GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetExecute(r)
}

/*
GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGet Get Block Reservations

Get a list of CIDR Reservations for the target Block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest
*/
func (a *SpacesAPIService) GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGet(ctx context.Context, space string, block string) ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest {
	return ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return []ReservationExpand
func (a *SpacesAPIService) GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetExecute(r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGetRequest) ([]ReservationExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReservationExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.settled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settled", r.settled, "form", "")
	} else {
		var defaultValue bool = false
		r.settled = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	reservation string
	authorization *string
}

// Azure Bearer token
func (r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest) Authorization(authorization string) ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest) Execute() (*ReservationExpand, *http.Response, error) {
	return r.ApiService.GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetExecute(r)
}

/*
GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGet Get Block Reservation

Get the details of a specific CIDR Reservation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param reservation ID of the target Reservation
 @return ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest
*/
func (a *SpacesAPIService) GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGet(ctx context.Context, space string, block string, reservation string) ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest {
	return ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		reservation: reservation,
	}
}

// Execute executes the request
//  @return ReservationExpand
func (a *SpacesAPIService) GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetExecute(r ApiGetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGetRequest) (*ReservationExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReservationExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetBlockReservationsApiSpacesSpaceBlocksBlockReservationsReservationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/reservations/{reservation}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"reservation"+"}", url.PathEscape(parameterValueToString(r.reservation, "reservation")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlocksApiSpacesSpaceBlocksGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	expand *bool
	utilization *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiGetBlocksApiSpacesSpaceBlocksGetRequest) Expand(expand bool) ApiGetBlocksApiSpacesSpaceBlocksGetRequest {
	r.expand = &expand
	return r
}

// Append utilization information for each network
func (r ApiGetBlocksApiSpacesSpaceBlocksGetRequest) Utilization(utilization bool) ApiGetBlocksApiSpacesSpaceBlocksGetRequest {
	r.utilization = &utilization
	return r
}

// Azure Bearer token
func (r ApiGetBlocksApiSpacesSpaceBlocksGetRequest) Authorization(authorization string) ApiGetBlocksApiSpacesSpaceBlocksGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetBlocksApiSpacesSpaceBlocksGetRequest) Execute() (*ResponseGetBlocksApiSpacesSpaceBlocksGet, *http.Response, error) {
	return r.ApiService.GetBlocksApiSpacesSpaceBlocksGetExecute(r)
}

/*
GetBlocksApiSpacesSpaceBlocksGet Get all Blocks within a Space

Get a list of all Blocks within a specific Space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiGetBlocksApiSpacesSpaceBlocksGetRequest
*/
func (a *SpacesAPIService) GetBlocksApiSpacesSpaceBlocksGet(ctx context.Context, space string) ApiGetBlocksApiSpacesSpaceBlocksGetRequest {
	return ApiGetBlocksApiSpacesSpaceBlocksGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return ResponseGetBlocksApiSpacesSpaceBlocksGet
func (a *SpacesAPIService) GetBlocksApiSpacesSpaceBlocksGetExecute(r ApiGetBlocksApiSpacesSpaceBlocksGetRequest) (*ResponseGetBlocksApiSpacesSpaceBlocksGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetBlocksApiSpacesSpaceBlocksGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetBlocksApiSpacesSpaceBlocksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	if r.utilization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "utilization", r.utilization, "form", "")
	} else {
		var defaultValue bool = false
		r.utilization = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest) Authorization(authorization string) ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest) Execute() (*ExtNet, *http.Response, error) {
	return r.ApiService.GetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetExecute(r)
}

/*
GetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGet Get External Network

Get the details of a specific External Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @return ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest
*/
func (a *SpacesAPIService) GetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGet(ctx context.Context, space string, block string, external string) ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest {
	return ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
	}
}

// Execute executes the request
//  @return ExtNet
func (a *SpacesAPIService) GetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetExecute(r ApiGetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGetRequest) (*ExtNet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtNet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalNetworkApiSpacesSpaceBlocksBlockExternalsExternalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest) Authorization(authorization string) ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest) Execute() ([]ExtNet, *http.Response, error) {
	return r.ApiService.GetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetExecute(r)
}

/*
GetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGet List External Networks

Get a list of External Networks which are currently associated to the target Block.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest
*/
func (a *SpacesAPIService) GetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGet(ctx context.Context, space string, block string) ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest {
	return ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return []ExtNet
func (a *SpacesAPIService) GetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetExecute(r ApiGetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGetRequest) ([]ExtNet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExtNet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalNetworksApiSpacesSpaceBlocksBlockExternalsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest) Authorization(authorization string) ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest) Execute() (*ExtSubnet, *http.Response, error) {
	return r.ApiService.GetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetExecute(r)
}

/*
GetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGet Get External Network Subnet

Get the details of a specific External Subnet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @param subnet Name of the target external subnet
 @return ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest
*/
func (a *SpacesAPIService) GetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGet(ctx context.Context, space string, block string, external string, subnet string) ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest {
	return ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return ExtSubnet
func (a *SpacesAPIService) GetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetExecute(r ApiGetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGetRequest) (*ExtSubnet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtSubnet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	endpoint string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest) Authorization(authorization string) ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest) Execute() (*ExtEndpoint, *http.Response, error) {
	return r.ApiService.GetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetExecute(r)
}

/*
GetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGet Get External Network Subnet Endpoint

Get the details of a specific External Subnet Endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target external network
 @param subnet Name of the target external subnet
 @param endpoint Name of the target external subnet endpoint
 @return ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest
*/
func (a *SpacesAPIService) GetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGet(ctx context.Context, space string, block string, external string, subnet string, endpoint string) ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest {
	return ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
		endpoint: endpoint,
	}
}

// Execute executes the request
//  @return ExtEndpoint
func (a *SpacesAPIService) GetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetExecute(r ApiGetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGetRequest) (*ExtEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalSubnetEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints/{endpoint}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint"+"}", url.PathEscape(parameterValueToString(r.endpoint, "endpoint")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest) Authorization(authorization string) ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest) Execute() ([]ExtEndpoint, *http.Response, error) {
	return r.ApiService.GetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetExecute(r)
}

/*
GetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGet List External Network Subnet Endpoints

Get a list of Endpoints which are currently associated to the target External Network Subnet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target External Network
 @param subnet Name of the target External Network Subnet
 @return ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest
*/
func (a *SpacesAPIService) GetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGet(ctx context.Context, space string, block string, external string, subnet string) ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest {
	return ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return []ExtEndpoint
func (a *SpacesAPIService) GetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetExecute(r ApiGetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGetRequest) ([]ExtEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExtEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalSubnetEndpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	authorization *string
}

// Azure Bearer token
func (r ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest) Authorization(authorization string) ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest) Execute() ([]ExtSubnet, *http.Response, error) {
	return r.ApiService.GetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetExecute(r)
}

/*
GetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGet List External Network Subnets

Get a list of Subnets which are currently associated to the target External Network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @param external Name of the target External Network
 @return ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest
*/
func (a *SpacesAPIService) GetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGet(ctx context.Context, space string, block string, external string) ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest {
	return ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
	}
}

// Execute executes the request
//  @return []ExtSubnet
func (a *SpacesAPIService) GetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetExecute(r ApiGetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGetRequest) ([]ExtSubnet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExtSubnet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetExternalSubnetsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	settled *bool
	authorization *string
}

// Include settled reservations.
func (r ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest) Settled(settled bool) ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest {
	r.settled = &settled
	return r
}

// Azure Bearer token
func (r ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest) Authorization(authorization string) ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest) Execute() ([]ReservationExpand, *http.Response, error) {
	return r.ApiService.GetMultiBlockReservationsApiSpacesSpaceReservationsGetExecute(r)
}

/*
GetMultiBlockReservationsApiSpacesSpaceReservationsGet Get Reservations for all Blocks within a Space

Get a list of CIDR Reservations for all Blocks within the target Space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest
*/
func (a *SpacesAPIService) GetMultiBlockReservationsApiSpacesSpaceReservationsGet(ctx context.Context, space string) ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest {
	return ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return []ReservationExpand
func (a *SpacesAPIService) GetMultiBlockReservationsApiSpacesSpaceReservationsGetExecute(r ApiGetMultiBlockReservationsApiSpacesSpaceReservationsGetRequest) ([]ReservationExpand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ReservationExpand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetMultiBlockReservationsApiSpacesSpaceReservationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/reservations"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.settled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "settled", r.settled, "form", "")
	} else {
		var defaultValue bool = false
		r.settled = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpaceApiSpacesSpaceGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	expand *bool
	utilization *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiGetSpaceApiSpacesSpaceGetRequest) Expand(expand bool) ApiGetSpaceApiSpacesSpaceGetRequest {
	r.expand = &expand
	return r
}

// Append utilization information for each network
func (r ApiGetSpaceApiSpacesSpaceGetRequest) Utilization(utilization bool) ApiGetSpaceApiSpacesSpaceGetRequest {
	r.utilization = &utilization
	return r
}

// Azure Bearer token
func (r ApiGetSpaceApiSpacesSpaceGetRequest) Authorization(authorization string) ApiGetSpaceApiSpacesSpaceGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetSpaceApiSpacesSpaceGetRequest) Execute() (*ResponseGetSpaceApiSpacesSpaceGet, *http.Response, error) {
	return r.ApiService.GetSpaceApiSpacesSpaceGetExecute(r)
}

/*
GetSpaceApiSpacesSpaceGet Get Space Details

Get the details of a specific Space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @return ApiGetSpaceApiSpacesSpaceGetRequest
*/
func (a *SpacesAPIService) GetSpaceApiSpacesSpaceGet(ctx context.Context, space string) ApiGetSpaceApiSpacesSpaceGetRequest {
	return ApiGetSpaceApiSpacesSpaceGetRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return ResponseGetSpaceApiSpacesSpaceGet
func (a *SpacesAPIService) GetSpaceApiSpacesSpaceGetExecute(r ApiGetSpaceApiSpacesSpaceGetRequest) (*ResponseGetSpaceApiSpacesSpaceGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetSpaceApiSpacesSpaceGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetSpaceApiSpacesSpaceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	if r.utilization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "utilization", r.utilization, "form", "")
	} else {
		var defaultValue bool = false
		r.utilization = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpacesApiSpacesGetRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	expand *bool
	utilization *bool
	authorization *string
}

// Expand network references to full network objects
func (r ApiGetSpacesApiSpacesGetRequest) Expand(expand bool) ApiGetSpacesApiSpacesGetRequest {
	r.expand = &expand
	return r
}

// Append utilization information for each network
func (r ApiGetSpacesApiSpacesGetRequest) Utilization(utilization bool) ApiGetSpacesApiSpacesGetRequest {
	r.utilization = &utilization
	return r
}

// Azure Bearer token
func (r ApiGetSpacesApiSpacesGetRequest) Authorization(authorization string) ApiGetSpacesApiSpacesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetSpacesApiSpacesGetRequest) Execute() (*ResponseGetSpacesApiSpacesGet, *http.Response, error) {
	return r.ApiService.GetSpacesApiSpacesGetExecute(r)
}

/*
GetSpacesApiSpacesGet Get All Spaces

Get a list of all Spaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpacesApiSpacesGetRequest
*/
func (a *SpacesAPIService) GetSpacesApiSpacesGet(ctx context.Context) ApiGetSpacesApiSpacesGetRequest {
	return ApiGetSpacesApiSpacesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetSpacesApiSpacesGet
func (a *SpacesAPIService) GetSpacesApiSpacesGetExecute(r ApiGetSpacesApiSpacesGetRequest) (*ResponseGetSpacesApiSpacesGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetSpacesApiSpacesGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.GetSpacesApiSpacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	if r.utilization != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "utilization", r.utilization, "form", "")
	} else {
		var defaultValue bool = false
		r.utilization = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	jSONPatch *[]JSONPatch
	authorization *string
}

func (r ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest) JSONPatch(jSONPatch []JSONPatch) ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest {
	r.jSONPatch = &jSONPatch
	return r
}

// Azure Bearer token
func (r ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest) Authorization(authorization string) ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest) Execute() (*Block, *http.Response, error) {
	return r.ApiService.UpdateBlockApiSpacesSpaceBlocksBlockPatchExecute(r)
}


func (a *SpacesAPIService) UpdateBlockApiSpacesSpaceBlocksBlockPatch(ctx context.Context, space string, block string) ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest {
	return ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return Block
func (a *SpacesAPIService) UpdateBlockApiSpacesSpaceBlocksBlockPatchExecute(r ApiUpdateBlockApiSpacesSpaceBlocksBlockPatchRequest) (*Block, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Block
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateBlockApiSpacesSpaceBlocksBlockPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jSONPatch == nil {
		return localVarReturnValue, nil, reportError("jSONPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.jSONPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	requestBody *[]string
	authorization *string
}

func (r ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest) RequestBody(requestBody []string) ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest {
	r.requestBody = &requestBody
	return r
}

// Azure Bearer token
func (r ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest) Authorization(authorization string) ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest) Execute() ([]Network, *http.Response, error) {
	return r.ApiService.UpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutExecute(r)
}

/*
UpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPut Replace Block Networks

Replace the list of networks currently associated to the target Block with the following information:

- **[&lt;str&gt;]**: Array of Azure Resource ID's

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param space Name of the target Space
 @param block Name of the target Block
 @return ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest
*/
func (a *SpacesAPIService) UpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPut(ctx context.Context, space string, block string) ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest {
	return ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
	}
}

// Execute executes the request
//  @return []Network
func (a *SpacesAPIService) UpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutExecute(r ApiUpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPutRequest) ([]Network, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Network
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateBlockVnetsApiSpacesSpaceBlocksBlockNetworksPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/networks"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	endpoint string
	jSONPatch *[]JSONPatch
	authorization *string
}

func (r ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest) JSONPatch(jSONPatch []JSONPatch) ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest {
	r.jSONPatch = &jSONPatch
	return r
}

// Azure Bearer token
func (r ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest) Authorization(authorization string) ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest) Execute() (*ExtEndpoint, *http.Response, error) {
	return r.ApiService.UpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchExecute(r)
}

func (a *SpacesAPIService) UpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatch(ctx context.Context, space string, block string, external string, subnet string, endpoint string) ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest {
	return ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
		endpoint: endpoint,
	}
}

// Execute executes the request
//  @return ExtEndpoint
func (a *SpacesAPIService) UpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchExecute(r ApiUpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatchRequest) (*ExtEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateExtEndpointApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsEndpointPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints/{endpoint}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint"+"}", url.PathEscape(parameterValueToString(r.endpoint, "endpoint")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jSONPatch == nil {
		return localVarReturnValue, nil, reportError("jSONPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.jSONPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	jSONPatch *[]JSONPatch
	authorization *string
}

func (r ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest) JSONPatch(jSONPatch []JSONPatch) ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest {
	r.jSONPatch = &jSONPatch
	return r
}

// Azure Bearer token
func (r ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest) Authorization(authorization string) ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest) Execute() (*ExtNet, *http.Response, error) {
	return r.ApiService.UpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchExecute(r)
}

func (a *SpacesAPIService) UpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatch(ctx context.Context, space string, block string, external string) ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest {
	return ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
	}
}

// Execute executes the request
//  @return ExtNet
func (a *SpacesAPIService) UpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchExecute(r ApiUpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatchRequest) (*ExtNet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtNet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateExtNetworkApiSpacesSpaceBlocksBlockExternalsExternalPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jSONPatch == nil {
		return localVarReturnValue, nil, reportError("jSONPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.jSONPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	jSONPatch *[]JSONPatch
	authorization *string
}

func (r ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest) JSONPatch(jSONPatch []JSONPatch) ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest {
	r.jSONPatch = &jSONPatch
	return r
}

// Azure Bearer token
func (r ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest) Authorization(authorization string) ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest) Execute() (*ExtSubnet, *http.Response, error) {
	return r.ApiService.UpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchExecute(r)
}

func (a *SpacesAPIService) UpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatch(ctx context.Context, space string, block string, external string, subnet string) ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest {
	return ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return ExtSubnet
func (a *SpacesAPIService) UpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchExecute(r ApiUpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatchRequest) (*ExtSubnet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtSubnet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateExtSubnetApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jSONPatch == nil {
		return localVarReturnValue, nil, reportError("jSONPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.jSONPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	block string
	external string
	subnet string
	extEndpointReq *[]ExtEndpointReq
	authorization *string
}

func (r ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest) ExtEndpointReq(extEndpointReq []ExtEndpointReq) ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest {
	r.extEndpointReq = &extEndpointReq
	return r
}

// Azure Bearer token
func (r ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest) Authorization(authorization string) ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest) Execute() ([]ExtEndpoint, *http.Response, error) {
	return r.ApiService.UpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutExecute(r)
}

func (a *SpacesAPIService) UpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPut(ctx context.Context, space string, block string, external string, subnet string) ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest {
	return ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
		block: block,
		external: external,
		subnet: subnet,
	}
}

// Execute executes the request
//  @return []ExtEndpoint
func (a *SpacesAPIService) UpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutExecute(r ApiUpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPutRequest) ([]ExtEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExtEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateExternalSubnetEnpointsApiSpacesSpaceBlocksBlockExternalsExternalSubnetsSubnetEndpointsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}/blocks/{block}/externals/{external}/subnets/{subnet}/endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"block"+"}", url.PathEscape(parameterValueToString(r.block, "block")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"external"+"}", url.PathEscape(parameterValueToString(r.external, "external")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subnet"+"}", url.PathEscape(parameterValueToString(r.subnet, "subnet")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.extEndpointReq == nil {
		return localVarReturnValue, nil, reportError("extEndpointReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.extEndpointReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSpaceApiSpacesSpacePatchRequest struct {
	ctx context.Context
	ApiService *SpacesAPIService
	space string
	jSONPatch *[]JSONPatch
	authorization *string
}

func (r ApiUpdateSpaceApiSpacesSpacePatchRequest) JSONPatch(jSONPatch []JSONPatch) ApiUpdateSpaceApiSpacesSpacePatchRequest {
	r.jSONPatch = &jSONPatch
	return r
}

// Azure Bearer token
func (r ApiUpdateSpaceApiSpacesSpacePatchRequest) Authorization(authorization string) ApiUpdateSpaceApiSpacesSpacePatchRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUpdateSpaceApiSpacesSpacePatchRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateSpaceApiSpacesSpacePatchExecute(r)
}

func (a *SpacesAPIService) UpdateSpaceApiSpacesSpacePatch(ctx context.Context, space string) ApiUpdateSpaceApiSpacesSpacePatchRequest {
	return ApiUpdateSpaceApiSpacesSpacePatchRequest{
		ApiService: a,
		ctx: ctx,
		space: space,
	}
}

// Execute executes the request
//  @return interface{}
func (a *SpacesAPIService) UpdateSpaceApiSpacesSpacePatchExecute(r ApiUpdateSpaceApiSpacesSpacePatchRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SpacesAPIService.UpdateSpaceApiSpacesSpacePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/spaces/{space}"
	localVarPath = strings.Replace(localVarPath, "{"+"space"+"}", url.PathEscape(parameterValueToString(r.space, "space")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jSONPatch == nil {
		return localVarReturnValue, nil, reportError("jSONPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	// body params
	localVarPostBody = r.jSONPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
